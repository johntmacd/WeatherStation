#include "arduino_secrets.h"
/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled 3"
  https://create.arduino.cc/cloud/things/f3706009-9966-4586-af6d-950b122aa379 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float humidIOT;
  float rainIOT;
  float tempIOT;
  float windDirIOT;
  float windSpeedIOT;
  bool lED;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/
#include <Wire.h>
#include <SPI.h>

#include "Modulino.h"
#include "SparkFun_Weather_Meter_Kit_Arduino_Library.h"
#include "Arduino_LED_Matrix.h"
#include "thingProperties.h"

pinMode(13, OUTPUT);

ModulinoThermo thermo;
ArduinoLEDMatrix matrix;

float temperature = -273.15;
float humidity = 0.0;

int windDirectionPin = A3;
int windSpeedPin = 3;
int rainfallPin = 2;

SFEWeatherMeterKit weatherMeterKit(windDirectionPin, windSpeedPin, rainfallPin);

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 

  Modulino.begin();
  thermo.begin();
  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

    matrix.begin();
  delay(100);
  

    Serial.println(F("SparkFun Weather Meter Kit Example 2 - Manual Calibration"));
    Serial.println();
    Serial.println(F("Note - this example demonstrates how to manually set the"));
    Serial.println(F("calibration parameters once you know what they are for your"));
    Serial.println(F("set up. If you don't know what values to use, check out"));
    Serial.println(F("Example 3, which walks you through it! The values used in"));
    Serial.println(F("this example are all defaults, so you may need to change them."));

    // Here we create a struct to hold all the calibration parameters
    SFEWeatherMeterKitCalibrationParams calibrationParams = weatherMeterKit.getCalibrationParams();
  
    calibrationParams.vaneADCValues[WMK_ANGLE_0_0] = 788;
    calibrationParams.vaneADCValues[WMK_ANGLE_22_5] = 407;
    calibrationParams.vaneADCValues[WMK_ANGLE_45_0] = 562;
    calibrationParams.vaneADCValues[WMK_ANGLE_67_5] = 84;
    calibrationParams.vaneADCValues[WMK_ANGLE_90_0] = 93;
    calibrationParams.vaneADCValues[WMK_ANGLE_112_5] = 66;
    calibrationParams.vaneADCValues[WMK_ANGLE_135_0] = 185;
    calibrationParams.vaneADCValues[WMK_ANGLE_157_5] = 126;
    calibrationParams.vaneADCValues[WMK_ANGLE_180_0] = 288;
    calibrationParams.vaneADCValues[WMK_ANGLE_202_5] = 245;
    calibrationParams.vaneADCValues[WMK_ANGLE_225_0] = 632;
    calibrationParams.vaneADCValues[WMK_ANGLE_247_5] = 601;
    calibrationParams.vaneADCValues[WMK_ANGLE_270_0] = 948;
    calibrationParams.vaneADCValues[WMK_ANGLE_292_5] = 829;
    calibrationParams.vaneADCValues[WMK_ANGLE_315_0] = 889;
    calibrationParams.vaneADCValues[WMK_ANGLE_337_5] = 704;

    // The rainfall detector contains a small cup that collects rain water. When
    // the cup fills, the water is dumped and the total rainfall is incremented
    // by some value. This value defaults to 0.2794mm of rain per count, as
    // specified by the datasheet
    calibrationParams.mmPerRainfallCount = 0.2794;

    // The rainfall detector switch can sometimes bounce, causing multiple extra
    // triggers. This input is debounced by ignoring extra triggers within a
    // time window, which defaults to 100ms
    calibrationParams.minMillisPerRainfall = 100;

    // The anemometer contains a switch that opens and closes as it spins. The
    // rate at which the switch closes depends on the wind speed. The datasheet
    // states that a wind of 2.4kph causes the switch to close once per second
    calibrationParams.kphPerCountPerSec = 2.4;

    // Because the anemometer generates discrete pulses as it rotates, it's not
    // possible to measure the wind speed exactly at any point in time. A filter
    // is implemented in the library that averages the wind speed over a certain
    // time period, which defaults to 1 second. Longer intervals result in more
    // accurate measurements, but cause delay in the measurement
    calibrationParams.windSpeedMeasurementPeriodMillis = 1000;

    // Now we can set all the calibration parameters at once
    weatherMeterKit.setCalibrationParams(calibrationParams);

    // Begin weather meter kit
    weatherMeterKit.begin();
}

void loop() {
  ArduinoCloud.update();
  // Your code here 
    temperature = (thermo.getTemperature() * 9 / 5) + 32;
  humidity = thermo.getHumidity();

  //Convert the temperature float to a string with 1 decimal point shown
  //and add °C at the end
  String temperature_text = String(temperature, 1) + "°F";

  //Convert the humidity float to a string with no decimal points shown
  //and add % at the end
  String humidity_text = String(humidity, 0) + "%";

  //Print each of the sensor values on serial
  Serial.print("Temperature ");
  Serial.print(temperature_text + "         ");
  tempIOT = temperature;
  Serial.print("Humidity ");
  Serial.println(humidity_text);
  humidIOT = humidity;

  //Show on the UNO R4 WiFi LED matrix the data

 
  
    Serial.print(F("Wind direction (degrees): "));
    Serial.print(weatherMeterKit.getWindDirection(), 1);
    Serial.print(F("\t\t"));
    windDirIOT = weatherMeterKit.getWindDirection()
    Serial.print(F("Wind speed (kph): "));
    Serial.print(weatherMeterKit.getWindSpeed(), 1);
    Serial.print(F("\t\t"));
    windSpeedIOT = weatherMeterKit.getWindSpeed()
    Serial.print(F("Total rainfall (mm): "));
    Serial.println(weatherMeterKit.getTotalRainfall(), 1);
    rainIOT = weatherMeterKit.getTotalRainfall();


  Serial.println();
  delay(1000);
  
}

/*
  Since TempIOT is READ_WRITE variable, onTempIOTChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onTempIOTChange()  {
  // Add your code here to act upon TempIOT change
}

/*
  Since HumidIOT is READ_WRITE variable, onHumidIOTChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onHumidIOTChange()  {
  // Add your code here to act upon HumidIOT change
}

/*
  Since LED is READ_WRITE variable, onLEDChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLEDChange()  {
  // Add your code here to act upon LED change
   if (lED == 1){
    digitalWrite(13,HIGH);}
  else{
    digitalWrite(13,LOW);
  }
}

/*
  Since RainIOT is READ_WRITE variable, onRainIOTChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onRainIOTChange()  {
  // Add your code here to act upon RainIOT change
}

/*
  Since WindDir is READ_WRITE variable, onWindDirChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onWindDirChange()  {
  // Add your code here to act upon WindDir change
}

/*
  Since WindSpeedIOT is READ_WRITE variable, onWindSpeedIOTChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onWindSpeedIOTChange()  {
  // Add your code here to act upon WindSpeedIOT change
}

/*
  Since WindDirIOT is READ_WRITE variable, onWindDirIOTChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onWindDirIOTChange()  {
  // Add your code here to act upon WindDirIOT change
}
